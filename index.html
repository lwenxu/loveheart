<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>ğŸ’—</title>

    <script src="result.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #heart {
            display: block;
        }
    </style>
</head>

<body style="background-color:#000;" onload="onload()">
    <canvas id="heart" width="1800" height="900"></canvas>
</body>

<script>
    // å­˜å‚¨è¾¹ç•Œä¿¡æ¯
    let minX, minY, maxX, maxY;
    let offscreenCanvas, offscreenCtx;
    let scale = 1;

    // ç²’å­ç³»ç»Ÿ
    let tornadoParticles = [];  // é¾™å·é£ç²’å­
    let trayParticles = [];     // æ‰˜ç›˜ä¸Šçš„ç²’å­
    let heartBottomY = 0;       // çˆ±å¿ƒåº•éƒ¨Yåæ ‡
    let heartCenterX = 0;       // çˆ±å¿ƒä¸­å¿ƒXåæ ‡
    let trayY = 0;              // æ‰˜ç›˜Yåæ ‡
    let globalRotation = 0;     // å…¨å±€æ—‹è½¬è§’åº¦

    // æ‰˜ç›˜ç²’å­ç±»ï¼ˆä½¿ç”¨æåæ ‡ï¼‰
    class TrayParticle {
        constructor(angle, radiusX, radiusY, size, hue, alpha) {
            this.angle = angle;
            this.radiusX = radiusX;
            this.radiusY = radiusY;
            this.size = size;
            this.hue = hue;
            this.alpha = alpha;
            this.speed = 0.008 + Math.random() * 0.012; // æ—‹è½¬é€Ÿåº¦
        }
    }

    // é¾™å·é£ç²’å­ç±»ï¼ˆæ°”æ³¡æ•ˆæœï¼‰
    class TornadoParticle {
        constructor(angle, radius, y, size, alpha) {
            this.angle = angle;
            this.radius = radius;
            this.y = y;
            this.size = size;
            this.alpha = alpha;
            this.speed = 0.02 + Math.random() * 0.03; // æ—‹è½¬é€Ÿåº¦
            this.riseSpeed = 1 + Math.random() * 1.5;   // ä¸Šå‡é€Ÿåº¦ï¼ˆæ…¢ä¸€äº›ï¼‰
            this.wobble = Math.random() * Math.PI * 2;  // æ‘†åŠ¨ç›¸ä½
            this.wobbleSpeed = 0.05 + Math.random() * 0.05; // æ‘†åŠ¨é€Ÿåº¦
        }
    }

    // åˆå§‹åŒ–æ‰˜ç›˜ç²’å­ï¼ˆæ¤­åœ†å½¢åˆ†å¸ƒï¼‰
    function initTrayParticles(canvas) {
        trayY = canvas.height * 0.88;
        const trayWidth = canvas.width * 0.45;
        const trayHeight = 35;

        for (let i = 0; i < 2000; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radiusX = (0.2 + Math.random() * 0.8) * trayWidth;
            const radiusY = (0.2 + Math.random() * 0.8) * trayHeight;
            const hue = 280 + Math.random() * 40;
            const size = 1 + Math.random() * 2;
            const alpha = 0.4 + Math.random() * 0.6;

            trayParticles.push(new TrayParticle(
                angle, radiusX, radiusY, size, hue, alpha
            ));
        }
    }

    // ç”Ÿæˆé¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼Œä»æ‰˜ç›˜ä¸Šå‡åˆ°çˆ±å¿ƒï¼‰
    function spawnTornadoParticle(canvas) {
        const angle = Math.random() * Math.PI * 2;
        const startRadius = 20 + Math.random() * 140; // æ›´åˆ†æ•£çš„èµ·å§‹ä½ç½®
        const size = 2 + Math.random() * 4;  // æ›´å¤§çš„æ°”æ³¡
        const alpha = 0.3 + Math.random() * 0.5;  // æ›´é€æ˜ä¸€äº›

        tornadoParticles.push(new TornadoParticle(
            angle, startRadius, trayY, size, alpha
        ));
    }

    // æ›´æ–°ç²’å­
    function updateParticles(canvas) {
        // æ›´æ–°å…¨å±€æ—‹è½¬
        globalRotation += 0.02;

        // æ›´æ–°æ‰˜ç›˜ç²’å­ï¼ˆæ—‹è½¬ï¼‰
        for (let p of trayParticles) {
            p.angle += p.speed;
        }

        // æ›´æ–°é¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼‰
        for (let i = tornadoParticles.length - 1; i >= 0; i--) {
            const p = tornadoParticles[i];

            // è®¡ç®—è¿›åº¦ï¼š0 = æ‰˜ç›˜ä½ç½®ï¼Œ1 = çˆ±å¿ƒåº•éƒ¨
            const progress = Math.max(0, Math.min(1, (trayY - p.y) / (trayY - heartBottomY)));

            // ç¼“æ…¢æ—‹è½¬
            p.angle += p.speed;

            // æ°”æ³¡æ‘†åŠ¨
            p.wobble += p.wobbleSpeed;

            // ä¸Šå‡é€Ÿåº¦ï¼ˆæ°”æ³¡ç¼“æ…¢ä¸Šå‡ï¼‰
            p.y -= p.riseSpeed;

            // åŒé”¥å½¢é¾™å·é£ï¼šä¸‹é¢å¤§é”¥å½¢ + ä¸Šé¢å°é”¥å½¢
            const midPoint = 0.5;
            const bottomRadius = 160;
            const midRadius = 30;
            const topRadius = 60;
            const endRadius = 5;

            let targetRadius;
            if (progress < midPoint) {
                const t = progress / midPoint;
                targetRadius = bottomRadius * (1 - t) + midRadius * t;
            } else {
                const t = (progress - midPoint) / (1 - midPoint);
                if (t < 0.3) {
                    const t2 = t / 0.3;
                    targetRadius = midRadius * (1 - t2) + topRadius * t2;
                } else {
                    const t2 = (t - 0.3) / 0.7;
                    targetRadius = topRadius * (1 - t2) + endRadius * t2;
                }
            }
            p.radius += (targetRadius - p.radius) * 0.1;

            // é€æ˜åº¦å˜åŒ–
            if (progress > 0.95) {
                p.alpha -= 0.15;
            }

            // åˆ°è¾¾çˆ±å¿ƒåº•éƒ¨æˆ–æ¶ˆå¤±
            if (p.y < heartBottomY || p.alpha <= 0) {
                tornadoParticles.splice(i, 1);
            }
        }
    }

    // ç»˜åˆ¶æ‰˜ç›˜ç²’å­ï¼ˆåœ¨çˆ±å¿ƒä¸‹é¢ï¼‰
    function drawTrayParticles(ctx, canvas) {
        const centerX = canvas.width / 2;

        for (let p of trayParticles) {
            const x = centerX + Math.cos(p.angle) * p.radiusX;
            const y = trayY + Math.sin(p.angle) * p.radiusY;

            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${p.hue}, 70%, 65%)`;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // ç»˜åˆ¶é¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼Œåœ¨çˆ±å¿ƒä¸Šé¢ï¼‰
    function drawTornadoParticles(ctx, canvas) {
        const centerX = canvas.width / 2;

        for (let p of tornadoParticles) {
            // æ·»åŠ æ‘†åŠ¨æ•ˆæœï¼Œè®©æ°”æ³¡å·¦å³é£˜åŠ¨
            const wobbleOffset = Math.sin(p.wobble) * 8;
            const x = centerX + Math.cos(p.angle) * p.radius + wobbleOffset;
            const y = p.y;

            // è®¡ç®—è¿›åº¦ï¼š0 = æ‰˜ç›˜ä½ç½®ï¼Œ1 = çˆ±å¿ƒåº•éƒ¨
            const progress = Math.max(0, Math.min(1, (trayY - p.y) / (trayY - heartBottomY)));

            // é¢œè‰²ä»ç´«è‰²(280)æ¸å˜åˆ°ç²‰çº¢/çº¢è‰²(340)
            const hue = 280 + progress * 60;
            const saturation = 70 + progress * 15;
            const lightness = 65 + progress * 10;

            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
        }

        ctx.globalAlpha = 1;
    }

    function onload() {
        const canvas = document.getElementById('heart');
        const ctx = canvas.getContext('2d');

        points = JSON.parse(points)

        // è®¡ç®—æ‰€æœ‰å¸§ä¸­çˆ±å¿ƒçš„åæ ‡è¾¹ç•Œ
        minX = Infinity; maxX = -Infinity;
        minY = Infinity; maxY = -Infinity;

        for (let j = 0; j < points.length; j++) {
            const frame_points = points[j];
            for (let i = 0; i < frame_points["x"].length; i++) {
                let y = frame_points["x"][i]
                let x = frame_points["y"][i]
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }

        // çˆ±å¿ƒåŸå§‹å°ºå¯¸ï¼ˆåŠ ä¸€ç‚¹è¾¹è·ï¼‰
        const heartWidth = maxX - minX + 1;
        const heartHeight = maxY - minY + 1;

        // åˆ›å»ºç¦»å± canvasï¼Œå°ºå¯¸ä¸ºçˆ±å¿ƒåŸå§‹å¤§å°
        offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = heartWidth;
        offscreenCanvas.height = heartHeight;
        offscreenCtx = offscreenCanvas.getContext('2d');

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä½¿çˆ±å¿ƒå ç”»å¸ƒçš„ 3/5
        const targetWidth = canvas.width * 0.6;
        const targetHeight = canvas.height * 0.6;
        scale = Math.min(targetWidth / heartWidth, targetHeight / heartHeight);

        // è®¡ç®—çˆ±å¿ƒä½ç½®ä¿¡æ¯ç”¨äºç²’å­ç³»ç»Ÿ
        const destWidth = offscreenCanvas.width * scale;
        const destHeight = offscreenCanvas.height * scale;
        heartCenterX = canvas.width / 2;
        // çˆ±å¿ƒåº•éƒ¨Yåæ ‡ï¼ˆå‘ä¸Šåç§»è®©ç²’å­èƒ½è¿æ¥åˆ°çˆ±å¿ƒå°–ç«¯ï¼‰
        heartBottomY = (canvas.height - destHeight) / 2 + destHeight - 100;

        // å¯ç”¨å›¾åƒå¹³æ»‘
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // åˆå§‹åŒ–æ‰˜ç›˜ç²’å­
        initTrayParticles(canvas);

        console.log('çˆ±å¿ƒåŸå§‹å°ºå¯¸:', { heartWidth, heartHeight });
        console.log('ç¼©æ”¾æ¯”ä¾‹:', scale);
        console.log('ç¼©æ”¾åå°ºå¯¸:', { width: heartWidth * scale, height: heartHeight * scale });

        let currentFrame = 0;

        // ä½¿ç”¨å•ä¸ªå®šæ—¶å™¨å¾ªç¯æ’­æ”¾æ‰€æœ‰å¸§
        setInterval(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            // ç”Ÿæˆæ–°çš„é¾™å·é£ç²’å­ï¼ˆç¨€ç–çš„æ°”æ³¡ï¼‰
            if (Math.random() < 0.9) {
                spawnTornadoParticle(canvas);
            }

            // æ›´æ–°ç²’å­
            updateParticles(canvas);

            // 1. å…ˆç»˜åˆ¶æ‰˜ç›˜ç²’å­ï¼ˆåœ¨æœ€åº•å±‚ï¼‰
            drawTrayParticles(ctx, canvas);

            // 2. ç»˜åˆ¶çˆ±å¿ƒ
            update(ctx, canvas, points[currentFrame])
            currentFrame = (currentFrame + 1) % points.length;

            // 3. æœ€åç»˜åˆ¶é¾™å·é£ç²’å­ï¼ˆåœ¨çˆ±å¿ƒä¸Šé¢ï¼Œè¿™æ ·èƒ½è¿æ¥åˆ°çˆ±å¿ƒï¼‰
            drawTornadoParticles(ctx, canvas);
        }, 50);
    }

    function update(ctx, canvas, frame_points) {
        // æ¸…ç©ºç¦»å± canvas
        offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

        // åœ¨ç¦»å± canvas ä¸Šä»¥åŸå§‹å°ºå¯¸ç»˜åˆ¶ï¼ˆæ¯ç‚¹1åƒç´ ï¼‰
        const imageData = offscreenCtx.createImageData(offscreenCanvas.width, offscreenCanvas.height);

        for (let i = 0; i < frame_points["x"].length; i++) {
            let origY = frame_points["x"][i]
            let origX = frame_points["y"][i]
            let data = frame_points["data"][i]

            // ç›¸å¯¹äºè¾¹ç•Œåç§»
            let x = origX - minX;
            let y = origY - minY;

            if (x >= 0 && x < offscreenCanvas.width && y >= 0 && y < offscreenCanvas.height) {
                let index = (x + y * offscreenCanvas.width) * 4;
                let r = Math.min(255, data[2] * 1.2);
                let g = data[1];
                let b = data[0];

                // è®¡ç®—äº®åº¦ï¼Œæš—è‰²ç²’å­è®¾ä¸ºé€æ˜
                let brightness = (r + g + b) / 3;
                let alpha = brightness < 10 ? 0 : 255;

                imageData.data[index + 0] = r;
                imageData.data[index + 1] = g;
                imageData.data[index + 2] = b;
                imageData.data[index + 3] = alpha;
            }
        }

        offscreenCtx.putImageData(imageData, 0, 0);

        // è®¡ç®—ç»˜åˆ¶ä½ç½®ï¼Œä½¿çˆ±å¿ƒå±…ä¸­
        const destWidth = offscreenCanvas.width * scale;
        const destHeight = offscreenCanvas.height * scale;
        const destX = (canvas.width - destWidth) / 2;
        const destY = (canvas.height - destHeight) / 2;

        // ç”¨ drawImage ç¼©æ”¾ç»˜åˆ¶åˆ°ä¸» canvasï¼ˆæµè§ˆå™¨è‡ªåŠ¨æ’å€¼ï¼‰
        ctx.drawImage(offscreenCanvas, destX, destY, destWidth, destHeight);
    }
</script>

</html>
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>ğŸ’—</title>

    <script src="result.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #heart {
            display: block;
        }
    </style>
</head>

<body style="background-color:#000;" onload="onload()">
    <canvas id="heart" width="1800" height="900"></canvas>
</body>

<script>
    // ç”¨äºå­˜å‚¨å˜æ¢å‚æ•°
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;
    let heartCenterX = 0;
    let heartCenterY = 0;

    function onload() {
        const canvas = document.getElementById('heart');
        const ctx = canvas.getContext('2d');

        points = JSON.parse(points)

        // è®¡ç®—æ‰€æœ‰å¸§ä¸­çˆ±å¿ƒçš„åæ ‡è¾¹ç•Œ
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        for (let j = 0; j < points.length; j++) {
            const frame_points = points[j];
            for (let i = 0; i < frame_points["x"].length; i++) {
                let y = frame_points["x"][i]
                let x = frame_points["y"][i]
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }

        // è®¡ç®—çˆ±å¿ƒçš„ä¸­å¿ƒç‚¹å’Œå°ºå¯¸
        heartCenterX = (minX + maxX) / 2;
        heartCenterY = (minY + maxY) / 2;
        const heartWidth = maxX - minX;
        const heartHeight = maxY - minY;

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä½¿çˆ±å¿ƒå ç”»å¸ƒçš„ 3/4
        const targetWidth = canvas.width * 0.75;
        const targetHeight = canvas.height * 0.75;
        scale = Math.min(targetWidth / heartWidth, targetHeight / heartHeight);

        // ç”»å¸ƒä¸­å¿ƒ
        const canvasCenterX = canvas.width / 2;
        const canvasCenterY = canvas.height / 2;

        console.log('ç¼©æ”¾æ¯”ä¾‹:', scale);
        console.log('çˆ±å¿ƒåŸå§‹å°ºå¯¸:', { heartWidth, heartHeight });
        console.log('ç¼©æ”¾åå°ºå¯¸:', { width: heartWidth * scale, height: heartHeight * scale });

        let currentFrame = 0;

        // ä½¿ç”¨å•ä¸ªå®šæ—¶å™¨å¾ªç¯æ’­æ”¾æ‰€æœ‰å¸§
        setInterval(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            update(ctx, canvas, points[currentFrame])
            currentFrame = (currentFrame + 1) % points.length;
        }, 50);
    }

    function update(ctx, canvas, frame_points) {
        const canvasCenterX = canvas.width / 2;
        const canvasCenterY = canvas.height / 2;

        // ä½¿ç”¨ Canvas 2D API ç»˜åˆ¶ï¼Œæ”¯æŒç¼©æ”¾
        for (let i = 0; i < frame_points["x"].length; i++) {
            let origY = frame_points["x"][i]
            let origX = frame_points["y"][i]
            let data = frame_points["data"][i]

            // ç›¸å¯¹äºçˆ±å¿ƒä¸­å¿ƒç¼©æ”¾ï¼Œç„¶åç§»åˆ°ç”»å¸ƒä¸­å¿ƒ
            let x = Math.round((origX - heartCenterX) * scale + canvasCenterX);
            let y = Math.round((origY - heartCenterY) * scale + canvasCenterY);

            // ç¡®ä¿åæ ‡åœ¨canvasèŒƒå›´å†…
            if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                const r = Math.min(255, data[2] * 1.2);
                const g = data[1];
                const b = data[0];

                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x, y, Math.ceil(scale), Math.ceil(scale));
            }
        }
    }
</script>

</html>
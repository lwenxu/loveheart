<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>ğŸ’—</title>

    <script src="result.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            background-color: #000;
        }

        #heart {
            display: block;
        }

        /* Gesture detection overlay */
        #gesturePrompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
            z-index: 10;
            display: none;
            animation: pulsePrompt 2s infinite;
        }

        @keyframes pulsePrompt {

            0%,
            100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                opacity: 0.8;
                transform: translate(-50%, -50%) scale(1.05);
            }
        }

        #cameraContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 11;
            display: none;
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        #cameraVideo {
            width: 320px;
            height: 240px;
            transform: scaleX(-1);
        }

        #cameraCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            transform: scaleX(-1);
            pointer-events: none;
        }

        #detectionStatus {
            position: fixed;
            top: 270px;
            right: 20px;
            z-index: 11;
            color: #ffeb3b;
            font-size: 18px;
            text-shadow: 1px 1px 5px rgba(0, 0, 0, 0.8);
            display: none;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 10px;
        }

        /* Memory mode */
        #memoryMode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 20;
            display: none;
            opacity: 0;
            transition: opacity 1.5s;
        }

        #memoryMode.show {
            opacity: 1;
        }

        #memoryImage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 80%;
            max-height: 80%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 1.5s;
        }

        #memoryImage.show {
            opacity: 1;
        }

        #memoryText {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 32px;
            text-align: center;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.9);
            opacity: 0;
            transition: opacity 1.5s;
            max-width: 80%;
            line-height: 1.6;
        }

        #memoryText.show {
            opacity: 1;
        }
    </style>
</head>

<body onload="onload()">
    <canvas id="heart" width="1800" height="900"></canvas>

    <!-- Gesture detection UI -->
    <div id="gesturePrompt">
        <span class="heart-icon">ğŸ’—</span><br>
        è¯·åŒæ‰‹è¶Šè¿‡å¤´é¡¶æ¯”çˆ±å¿ƒ<br>
        <span style="font-size: 24px;">è§£é”æˆ‘ä»¬çš„å›å¿†</span>
    </div>

    <div id="cameraContainer">
        <video id="cameraVideo" autoplay playsinline></video>
        <canvas id="cameraCanvas"></canvas>
    </div>

    <div id="detectionStatus">ç­‰å¾…æ£€æµ‹...</div>

    <!-- Memory mode -->
    <div id="memoryMode">
        <img id="memoryImage" src="" alt="Memory">
        <div id="memoryText"></div>
    </div>
</body>

<script>
    // å­˜å‚¨è¾¹ç•Œä¿¡æ¯
    let minX, minY, maxX, maxY;
    let offscreenCanvas, offscreenCtx;
    let scale = 1;

    // ç²’å­ç³»ç»Ÿ
    let tornadoParticles = [];  // é¾™å·é£ç²’å­
    let trayParticles = [];     // æ‰˜ç›˜ä¸Šçš„ç²’å­
    let stars = [];             // æ˜Ÿæ˜Ÿ
    let meteors = [];           // æµæ˜Ÿ
    let fireflies = [];         // è¤ç«è™«å…‰ç‚¹
    let fireworks = [];         // çƒŸèŠ±
    let fireworkParticles = []; // çƒŸèŠ±ç²’å­
    let heartBottomY = 0;       // çˆ±å¿ƒåº•éƒ¨Yåæ ‡
    let heartCenterX = 0;       // çˆ±å¿ƒä¸­å¿ƒXåæ ‡
    let heartTopY = 0;          // çˆ±å¿ƒé¡¶éƒ¨Yåæ ‡
    let trayY = 0;              // æ‰˜ç›˜Yåæ ‡
    let globalRotation = 0;     // å…¨å±€æ—‹è½¬è§’åº¦
    let heartGlowPhase = 0;     // çˆ±å¿ƒå…‰æ™•ç›¸ä½

    // æ‰˜ç›˜ç²’å­ç±»ï¼ˆä½¿ç”¨æåæ ‡ï¼‰
    class TrayParticle {
        constructor(angle, radiusX, radiusY, size, hue, alpha) {
            this.angle = angle;
            this.radiusX = radiusX;
            this.radiusY = radiusY;
            this.size = size;
            this.hue = hue;
            this.alpha = alpha;
            this.speed = 0.008 + Math.random() * 0.012; // æ—‹è½¬é€Ÿåº¦
        }
    }

    // é¾™å·é£ç²’å­ç±»ï¼ˆæ°”æ³¡æ•ˆæœï¼‰
    class TornadoParticle {
        constructor(angle, radius, y, size, alpha) {
            this.angle = angle;
            this.radius = radius;
            this.y = y;
            this.size = size;
            this.alpha = alpha;
            this.speed = 0.02 + Math.random() * 0.03; // æ—‹è½¬é€Ÿåº¦
            this.riseSpeed = 1 + Math.random() * 1.5;   // ä¸Šå‡é€Ÿåº¦ï¼ˆæ…¢ä¸€äº›ï¼‰
            this.wobble = Math.random() * Math.PI * 2;  // æ‘†åŠ¨ç›¸ä½
            this.wobbleSpeed = 0.05 + Math.random() * 0.05; // æ‘†åŠ¨é€Ÿåº¦
        }
    }

    // æ˜Ÿæ˜Ÿç±»
    class Star {
        constructor(x, y, size, brightness) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.brightness = brightness;
            this.baseBrightness = brightness;
            this.twinkleSpeed = 0.02 + Math.random() * 0.03;
            this.twinklePhase = Math.random() * Math.PI * 2;
        }
    }

    // æµæ˜Ÿç±»
    class Meteor {
        constructor(x, y, angle, speed, length, brightness = 1) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.speed = speed;
            this.length = length;
            this.brightness = brightness; // äº®åº¦ï¼Œå¤§æµæ˜Ÿä¼šæ›´äº®
            this.alpha = 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
        }
    }

    // è¤ç«è™«ç±»
    class Firefly {
        constructor(x, y, size, hue) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.hue = hue;
            this.vx = (Math.random() - 0.5) * 0.5;
            this.vy = (Math.random() - 0.5) * 0.5;
            this.brightness = Math.random();
            this.pulseSpeed = 0.02 + Math.random() * 0.03;
            this.pulsePhase = Math.random() * Math.PI * 2;
        }
    }

    // çƒŸèŠ±ç±»ï¼ˆä¸Šå‡ä¸­çš„ç«ç®­ï¼‰
    class Firework {
        constructor(x, y, targetY, hue, type) {
            this.x = x;
            this.y = y;
            this.targetY = targetY;
            this.hue = hue;
            this.type = type; // çˆ†ç‚¸ç±»å‹ï¼š1=æ—‹è½¬æ‰©å¤§ï¼Œ2=è§„åˆ™åœ†å½¢ï¼Œ3=äºŒæ¬¡çˆ†ç‚¸
            this.vy = -12 - Math.random() * 6; // å‘ä¸Šé€Ÿåº¦ï¼Œæ›´å¿«
            this.gravity = 0.15;
            this.exploded = false;
            this.trail = []; // å°¾è¿¹
        }
    }

    // çƒŸèŠ±ç²’å­ç±»ï¼ˆçˆ†ç‚¸åçš„ç²’å­ï¼‰
    class FireworkParticle {
        constructor(x, y, hue, vx, vy, type, secondaryColor) {
            this.x = x;
            this.y = y;
            this.startX = x; // è®°å½•èµ·å§‹ä½ç½®
            this.startY = y;
            this.hue = hue;
            this.secondaryColor = secondaryColor || null;
            this.vx = vx;
            this.vy = vy;
            this.alpha = 1;
            this.gravity = 0.05;
            this.friction = 0.99;
            this.type = type;
            this.size = 2;

            // ç±»å‹1ï¼šå‘å¤–æ‰©æ•£ï¼ŒåŠå¾„é™åˆ¶
            if (type === 1) {
                this.maxRadius = 50; // æœ€å¤§æ‰©æ•£åŠå¾„çº¦3cm
                this.distanceTraveled = 0;
            }

            // ç±»å‹2ï¼šè§„åˆ™åœ†å½¢
            if (type === 2) {
                // æ— ç‰¹æ®Šå±æ€§
            }

            // ç±»å‹3ï¼šäºŒæ¬¡çˆ†ç‚¸
            if (type === 3) {
                this.hasExploded = false;
                this.explosionTime = 40; // å›ºå®šæ—¶é—´ï¼Œè®©æ‰€æœ‰ç²’å­åŒæ—¶çˆ†ç‚¸
                this.life = 0;
            }
        }
    }

    // åˆå§‹åŒ–æ‰˜ç›˜ç²’å­ï¼ˆæ¤­åœ†å½¢åˆ†å¸ƒï¼‰
    function initTrayParticles(canvas) {
        trayY = canvas.height * 0.88;
        const trayWidth = canvas.width * 0.45;
        const trayHeight = 35;

        for (let i = 0; i < 4000; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radiusX = (0.2 + Math.random() * 0.8) * trayWidth;
            const radiusY = (0.2 + Math.random() * 0.8) * trayHeight;
            const hue = 280 + Math.random() * 40;
            const size = 1 + Math.random() * 2;
            const alpha = 0.4 + Math.random() * 0.6;

            trayParticles.push(new TrayParticle(
                angle, radiusX, radiusY, size, hue, alpha
            ));
        }
    }

    // åˆå§‹åŒ–æ˜Ÿæ˜Ÿ
    function initStars(canvas) {
        for (let i = 0; i < 500; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 0.5 + Math.random() * 1.5;
            const brightness = 0.3 + Math.random() * 0.7;
            stars.push(new Star(x, y, size, brightness));
        }
    }

    // åˆå§‹åŒ–è¤ç«è™«
    function initFireflies(canvas) {
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = 2 + Math.random() * 3;
            const hue = 40 + Math.random() * 20; // é‡‘é»„è‰²
            fireflies.push(new Firefly(x, y, size, hue));
        }
    }

    // ç”Ÿæˆæµæ˜Ÿ
    function spawnMeteor(canvas) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height * 0.3; // ä¸ŠåŠéƒ¨åˆ†
        const angle = Math.PI / 4 + Math.random() * Math.PI / 6; // å‘å³ä¸‹

        // 15% æ¦‚ç‡ç”Ÿæˆå¤§æµæ˜Ÿ
        const isBigMeteor = Math.random() < 0.15;

        if (isBigMeteor) {
            // å¤§æµæ˜Ÿï¼šæ›´å¿«ã€æ›´é•¿ã€æ›´äº®
            const speed = 12 + Math.random() * 6;
            const length = 150 + Math.random() * 200;
            const brightness = 1.8;
            meteors.push(new Meteor(x, y, angle, speed, length, brightness));
        } else {
            // æ™®é€šæµæ˜Ÿ
            const speed = 8 + Math.random() * 4;
            const length = 80 + Math.random() * 120;
            meteors.push(new Meteor(x, y, angle, speed, length, 1));
        }
    }

    // ç”Ÿæˆé¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼Œä»æ‰˜ç›˜ä¸Šå‡åˆ°çˆ±å¿ƒï¼‰
    function spawnTornadoParticle(canvas) {
        const angle = Math.random() * Math.PI * 2;
        const startRadius = 20 + Math.random() * 140; // æ›´åˆ†æ•£çš„èµ·å§‹ä½ç½®
        const size = 0.8 + Math.random() * 1.5;  // æ›´å°æ›´ç²¾è‡´çš„æ°”æ³¡
        const alpha = 0.4 + Math.random() * 0.6;  // æ›´ä¸é€æ˜ä¸€äº›

        tornadoParticles.push(new TornadoParticle(
            angle, startRadius, trayY, size, alpha
        ));
    }

    // ç”ŸæˆçƒŸèŠ±
    function spawnFirework(canvas) {
        const x = canvas.width * 0.2 + Math.random() * canvas.width * 0.6; // ä¸­é—´åŒºåŸŸ
        const y = canvas.height; // ä»åº•éƒ¨å‘å°„
        const targetY = canvas.height * 0.2 + Math.random() * canvas.height * 0.3; // ç›®æ ‡é«˜åº¦

        // éšæœºé¢œè‰²
        const hues = [0, 30, 60, 120, 180, 240, 280, 300, 330]; // çº¢ã€æ©™ã€é»„ã€ç»¿ã€é’ã€è“ã€ç´«ã€ç²‰
        const hue = hues[Math.floor(Math.random() * hues.length)];

        // éšæœºé€‰æ‹©çˆ†ç‚¸ç±»å‹
        const type = Math.floor(Math.random() * 3) + 1;

        fireworks.push(new Firework(x, y, targetY, hue, type));
    }

    // çƒŸèŠ±çˆ†ç‚¸
    function explodeFirework(firework) {
        if (firework.type === 1) {
            // ç±»å‹1ï¼šå‘å¤–æ‰©æ•£ï¼ŒåŠå¾„é™åˆ¶åœ¨50åƒç´ 
            const particleCount = 80;
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.1;
                const speed = 1.2 + Math.random() * 0.8;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                fireworkParticles.push(new FireworkParticle(firework.x, firework.y, firework.hue, vx, vy, 1));
            }
        } else if (firework.type === 2) {
            // ç±»å‹2ï¼šè§„åˆ™åœ†å½¢ï¼Œ2-3ç§é¢œè‰²+ç™½è‰²
            const particleCount = 100;
            const colors = [firework.hue, (firework.hue + 60) % 360, 0]; // ä¸»è‰²+ç¬¬äºŒè‰²+ç™½è‰²
            const numColors = 2 + Math.floor(Math.random() * 2); // 2-3ç§é¢œè‰²

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 0.5;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                // éšæœºé€‰æ‹©é¢œè‰²ï¼Œç™½è‰²å 30%
                let color;
                if (Math.random() < 0.3) {
                    color = null; // ç™½è‰²æ ‡è®°
                } else {
                    color = colors[Math.floor(Math.random() * numColors)];
                }

                fireworkParticles.push(new FireworkParticle(firework.x, firework.y, color || firework.hue, vx, vy, 2, color === null));
            }
        } else if (firework.type === 3) {
            // ç±»å‹3ï¼šæ•£å¼€ååŒæ—¶äºŒæ¬¡çˆ†ç‚¸æˆå°åœ†å½¢
            const particleCount = 25;
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;
                fireworkParticles.push(new FireworkParticle(firework.x, firework.y, firework.hue, vx, vy, 3));
            }
        }
    }

    // äºŒæ¬¡çˆ†ç‚¸ï¼ˆå°åœ†å½¢ï¼‰
    function secondaryExplosion(particle) {
        // æ¯ä¸ªç²’å­çˆ†ç‚¸æˆä¸€ä¸ªå°åœ†å½¢ï¼ˆ8ä¸ªç²’å­ï¼‰
        const miniParticles = 8;
        for (let i = 0; i < miniParticles; i++) {
            const angle = (Math.PI * 2 * i) / miniParticles;
            const speed = 0.6 + Math.random() * 0.4;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;
            // åˆ›å»ºäºŒæ¬¡çˆ†ç‚¸ç²’å­ï¼Œæ ‡è®°hasExplodedä¸ºtrueé˜²æ­¢å†æ¬¡çˆ†ç‚¸
            const p = new FireworkParticle(particle.x, particle.y, particle.hue, vx, vy, 3);
            p.hasExploded = true; // é˜²æ­¢ä¸‰æ¬¡çˆ†ç‚¸
            p.alpha = 0.8; // åˆå§‹é€æ˜åº¦æ›´ä½
            fireworkParticles.push(p);
        }
    }

    // æ›´æ–°ç²’å­
    function updateParticles(canvas) {
        // æ›´æ–°å…¨å±€æ—‹è½¬å’Œçˆ±å¿ƒå…‰æ™•
        globalRotation += 0.02;
        heartGlowPhase += 0.03;

        // æ›´æ–°æ˜Ÿæ˜Ÿé—ªçƒ
        for (let s of stars) {
            s.twinklePhase += s.twinkleSpeed;
            s.brightness = s.baseBrightness * (0.5 + 0.5 * Math.sin(s.twinklePhase));
        }

        // æ›´æ–°æµæ˜Ÿ
        for (let i = meteors.length - 1; i >= 0; i--) {
            const m = meteors[i];
            m.x += m.vx;
            m.y += m.vy;
            m.alpha -= 0.015;
            if (m.alpha <= 0 || m.x > canvas.width || m.y > canvas.height) {
                meteors.splice(i, 1);
            }
        }

        // æ›´æ–°è¤ç«è™«
        for (let f of fireflies) {
            f.x += f.vx;
            f.y += f.vy;
            f.pulsePhase += f.pulseSpeed;
            f.brightness = 0.3 + 0.7 * Math.sin(f.pulsePhase);

            // è¾¹ç•Œåå¼¹
            if (f.x < 0 || f.x > canvas.width) f.vx *= -1;
            if (f.y < 0 || f.y > canvas.height) f.vy *= -1;

            // ä¿æŒåœ¨è¾¹ç•Œå†…
            f.x = Math.max(0, Math.min(canvas.width, f.x));
            f.y = Math.max(0, Math.min(canvas.height, f.y));
        }

        // æ›´æ–°çƒŸèŠ±ï¼ˆä¸Šå‡ä¸­çš„ç«ç®­ï¼‰
        for (let i = fireworks.length - 1; i >= 0; i--) {
            const fw = fireworks[i];

            // è®°å½•å°¾è¿¹
            fw.trail.push({ x: fw.x, y: fw.y, alpha: 1 });
            if (fw.trail.length > 15) {
                fw.trail.shift();
            }

            // æ›´æ–°å°¾è¿¹é€æ˜åº¦
            for (let j = 0; j < fw.trail.length; j++) {
                fw.trail[j].alpha -= 0.05;
            }

            fw.vy += fw.gravity;
            fw.y += fw.vy;

            // åˆ°è¾¾ç›®æ ‡é«˜åº¦æˆ–å¼€å§‹ä¸‹è½æ—¶çˆ†ç‚¸
            if (fw.y <= fw.targetY || fw.vy >= 0) {
                explodeFirework(fw);
                fireworks.splice(i, 1);
            }
        }

        // æ›´æ–°çƒŸèŠ±ç²’å­
        for (let i = fireworkParticles.length - 1; i >= 0; i--) {
            const p = fireworkParticles[i];

            if (p.type === 1) {
                // ç±»å‹1ï¼šå‘å¤–æ‰©æ•£ï¼Œé™åˆ¶åŠå¾„
                p.vx *= p.friction;
                p.vy *= p.friction;
                p.vy += p.gravity * 0.3; // é™ä½é‡åŠ›å½±å“

                p.x += p.vx;
                p.y += p.vy;

                // è®¡ç®—è·ç¦»èµ·ç‚¹çš„è·ç¦»
                const dx = p.x - p.startX;
                const dy = p.y - p.startY;
                p.distanceTraveled = Math.sqrt(dx * dx + dy * dy);

                // åˆ°è¾¾æœ€å¤§åŠå¾„åå¿«é€Ÿç†„ç­
                if (p.distanceTraveled >= p.maxRadius) {
                    p.alpha -= 0.05; // å¿«é€Ÿæ¶ˆå¤±
                } else {
                    p.alpha -= 0.005; // æ­£å¸¸æ¶ˆå¤±
                }
            } else if (p.type === 2) {
                // ç±»å‹2ï¼šè§„åˆ™åœ†å½¢ï¼Œå¿«é€Ÿæ¶ˆå¤±
                p.vx *= p.friction;
                p.vy *= p.friction;
                p.vy += p.gravity;
                p.x += p.vx;
                p.y += p.vy;

                p.alpha -= 0.015; // æ¶ˆå¤±æ›´å¿«
            } else if (p.type === 3) {
                // ç±»å‹3ï¼šäºŒæ¬¡çˆ†ç‚¸
                p.vx *= p.friction;
                p.vy *= p.friction;
                p.vy += p.gravity;
                p.x += p.vx;
                p.y += p.vy;

                // æ‰€æœ‰ç²’å­åœ¨åŒä¸€æ—¶é—´çˆ†ç‚¸
                if (!p.hasExploded) {
                    p.life++;
                    if (p.life >= p.explosionTime) {
                        secondaryExplosion(p);
                        p.hasExploded = true;
                    }
                }

                // äºŒæ¬¡çˆ†ç‚¸çš„ç²’å­æ¶ˆå¤±æ›´å¿«
                if (p.hasExploded && p.alpha < 0.8) {
                    p.alpha -= 0.03; // æ›´å¿«æ¶ˆå¤±
                } else {
                    p.alpha -= 0.008;
                }
            }

            if (p.alpha <= 0) {
                fireworkParticles.splice(i, 1);
            }
        }

        // æ›´æ–°æ‰˜ç›˜ç²’å­ï¼ˆæ—‹è½¬ï¼‰
        for (let p of trayParticles) {
            p.angle += p.speed;
        }

        // æ›´æ–°é¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼‰
        for (let i = tornadoParticles.length - 1; i >= 0; i--) {
            const p = tornadoParticles[i];

            // è®¡ç®—è¿›åº¦ï¼š0 = æ‰˜ç›˜ä½ç½®ï¼Œ1 = çˆ±å¿ƒåº•éƒ¨
            const progress = Math.max(0, Math.min(1, (trayY - p.y) / (trayY - heartBottomY)));

            // ç¼“æ…¢æ—‹è½¬
            p.angle += p.speed;

            // æ°”æ³¡æ‘†åŠ¨
            p.wobble += p.wobbleSpeed;

            // ä¸Šå‡é€Ÿåº¦ï¼ˆæ°”æ³¡ç¼“æ…¢ä¸Šå‡ï¼‰
            p.y -= p.riseSpeed;

            // åŒé”¥å½¢é¾™å·é£ï¼šä¸‹é¢å¤§é”¥å½¢ + ä¸Šé¢å°é”¥å½¢
            const midPoint = 0.5;
            const bottomRadius = 160;
            const midRadius = 30;
            const topRadius = 60;
            const endRadius = 5;

            let targetRadius;
            if (progress < midPoint) {
                const t = progress / midPoint;
                targetRadius = bottomRadius * (1 - t) + midRadius * t;
            } else {
                const t = (progress - midPoint) / (1 - midPoint);
                if (t < 0.3) {
                    const t2 = t / 0.3;
                    targetRadius = midRadius * (1 - t2) + topRadius * t2;
                } else {
                    const t2 = (t - 0.3) / 0.7;
                    targetRadius = topRadius * (1 - t2) + endRadius * t2;
                }
            }
            p.radius += (targetRadius - p.radius) * 0.1;

            // é€æ˜åº¦å˜åŒ–
            if (progress > 0.95) {
                p.alpha -= 0.15;
            }

            // åˆ°è¾¾çˆ±å¿ƒåº•éƒ¨æˆ–æ¶ˆå¤±
            if (p.y < heartBottomY || p.alpha <= 0) {
                tornadoParticles.splice(i, 1);
            }
        }
    }

    // ç»˜åˆ¶æ‰˜ç›˜ç²’å­ï¼ˆåœ¨çˆ±å¿ƒä¸‹é¢ï¼‰
    function drawTrayParticles(ctx, canvas) {
        const centerX = canvas.width / 2;

        for (let p of trayParticles) {
            const x = centerX + Math.cos(p.angle) * p.radiusX;
            const y = trayY + Math.sin(p.angle) * p.radiusY;

            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${p.hue}, 70%, 65%)`;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // ç»˜åˆ¶é¾™å·é£ç²’å­ï¼ˆæ°”æ³¡æ•ˆæœï¼Œåœ¨çˆ±å¿ƒä¸Šé¢ï¼‰
    function drawTornadoParticles(ctx, canvas) {
        const centerX = canvas.width / 2;

        for (let p of tornadoParticles) {
            // æ·»åŠ æ‘†åŠ¨æ•ˆæœï¼Œè®©æ°”æ³¡å·¦å³é£˜åŠ¨
            const wobbleOffset = Math.sin(p.wobble) * 8;
            const x = centerX + Math.cos(p.angle) * p.radius + wobbleOffset;
            const y = p.y;

            // è®¡ç®—è¿›åº¦ï¼š0 = æ‰˜ç›˜ä½ç½®ï¼Œ1 = çˆ±å¿ƒåº•éƒ¨
            const progress = Math.max(0, Math.min(1, (trayY - p.y) / (trayY - heartBottomY)));

            // é¢œè‰²ä»ç´«è‰²(280)æ¸å˜åˆ°ç²‰çº¢/çº¢è‰²(340)
            const hue = 280 + progress * 60;
            const saturation = 70 + progress * 15;
            const lightness = 65 + progress * 10;

            ctx.beginPath();
            ctx.arc(x, y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
        }

        ctx.globalAlpha = 1;
    }

    // ç»˜åˆ¶æ˜Ÿç©ºèƒŒæ™¯
    function drawStars(ctx) {
        for (let s of stars) {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = s.brightness;
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // ç»˜åˆ¶æµæ˜Ÿ
    function drawMeteors(ctx) {
        for (let m of meteors) {
            const gradient = ctx.createLinearGradient(
                m.x, m.y,
                m.x - Math.cos(m.angle) * m.length,
                m.y - Math.sin(m.angle) * m.length
            );

            // å¤§æµæ˜Ÿæ›´äº®ï¼ˆå¸¦ä¸€ç‚¹è“è‰²å…‰æ™•ï¼‰
            const alpha = m.alpha * m.brightness;
            if (m.brightness > 1.5) {
                // å¤§æµæ˜Ÿå¸¦è“ç™½è‰²
                gradient.addColorStop(0, `rgba(200, 220, 255, ${Math.min(1, alpha)})`);
                gradient.addColorStop(0.3, `rgba(255, 255, 255, ${Math.min(1, alpha * 0.8)})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            } else {
                // æ™®é€šæµæ˜Ÿ
                gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
            }

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2 * m.brightness;  // å¤§æµæ˜Ÿæ›´ç²—
            ctx.beginPath();
            ctx.moveTo(m.x, m.y);
            ctx.lineTo(
                m.x - Math.cos(m.angle) * m.length,
                m.y - Math.sin(m.angle) * m.length
            );
            ctx.stroke();
        }
    }

    // ç»˜åˆ¶è¤ç«è™«
    function drawFireflies(ctx) {
        for (let f of fireflies) {
            // å…‰æ™•æ•ˆæœ
            const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size * 3);
            gradient.addColorStop(0, `hsla(${f.hue}, 100%, 70%, ${f.brightness * 0.8})`);
            gradient.addColorStop(0.5, `hsla(${f.hue}, 100%, 60%, ${f.brightness * 0.3})`);
            gradient.addColorStop(1, `hsla(${f.hue}, 100%, 50%, 0)`);

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.size * 3, 0, Math.PI * 2);
            ctx.fill();

            // æ ¸å¿ƒäº®ç‚¹
            ctx.fillStyle = `hsla(${f.hue}, 100%, 80%, ${f.brightness})`;
            ctx.beginPath();
            ctx.arc(f.x, f.y, f.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // ç»˜åˆ¶çƒŸèŠ±
    function drawFireworks(ctx) {
        // ç»˜åˆ¶ä¸Šå‡ä¸­çš„ç«ç®­
        for (let fw of fireworks) {
            // ç»˜åˆ¶å°¾è¿¹ï¼ˆæ›´é•¿çš„å°¾å·´ï¼‰
            if (fw.trail.length > 1) {
                for (let i = 0; i < fw.trail.length - 1; i++) {
                    const t1 = fw.trail[i];
                    const t2 = fw.trail[i + 1];
                    const alpha = t1.alpha * (i / fw.trail.length);

                    ctx.beginPath();
                    ctx.moveTo(t1.x, t1.y);
                    ctx.lineTo(t2.x, t2.y);
                    ctx.strokeStyle = `hsla(${fw.hue}, 100%, 70%, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }

            // ç«ç®­å¤´éƒ¨å‘å‡ºå¼ºå…‰
            const glowGradient = ctx.createRadialGradient(fw.x, fw.y, 0, fw.x, fw.y, 20);
            glowGradient.addColorStop(0, `hsla(${fw.hue}, 100%, 90%, 1)`);
            glowGradient.addColorStop(0.3, `hsla(${fw.hue}, 100%, 70%, 0.8)`);
            glowGradient.addColorStop(1, `hsla(${fw.hue}, 100%, 50%, 0)`);

            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(fw.x, fw.y, 20, 0, Math.PI * 2);
            ctx.fill();

            // ç«ç®­æ ¸å¿ƒ
            ctx.beginPath();
            ctx.arc(fw.x, fw.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#FFFFFF';
            ctx.fill();
        }

        // ç»˜åˆ¶çˆ†ç‚¸ç²’å­
        for (let p of fireworkParticles) {
            // æ ¹æ®ç±»å‹ç»˜åˆ¶ä¸åŒæ•ˆæœ
            if (p.type === 1) {
                // ç±»å‹1ï¼šå‘å¤–æ‰©æ•£ï¼Œé™åˆ¶åŠå¾„
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${p.hue}, 100%, 65%, ${p.alpha})`;
                ctx.fill();

                // å…‰æ™•
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2.5);
                gradient.addColorStop(0, `hsla(${p.hue}, 100%, 75%, ${p.alpha * 0.7})`);
                gradient.addColorStop(1, `hsla(${p.hue}, 100%, 55%, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            } else if (p.type === 2) {
                // ç±»å‹2ï¼šè§„åˆ™åœ†å½¢ï¼Œç™½è‰²æ›´äº®
                const isWhite = p.secondaryColor;
                if (isWhite) {
                    // ç™½è‰²ç²’å­
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha})`;
                    ctx.fill();

                    // ç™½è‰²å…‰æ™•
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 6);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${p.alpha * 0.8})`);
                    gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // å½©è‰²ç²’å­
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.alpha})`;
                    ctx.fill();

                    // å…‰æ™•
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 5);
                    gradient.addColorStop(0, `hsla(${p.hue}, 100%, 70%, ${p.alpha * 0.6})`);
                    gradient.addColorStop(1, `hsla(${p.hue}, 100%, 50%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (p.type === 3) {
                // ç±»å‹3ï¼šäºŒæ¬¡çˆ†ç‚¸ç²’å­ï¼ˆå°åœ†å½¢ï¼‰
                const size = p.hasExploded ? 1.5 : 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.alpha})`;
                ctx.fill();

                // å…‰æ™•
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2.5);
                gradient.addColorStop(0, `hsla(${p.hue}, 100%, 70%, ${p.alpha * 0.7})`);
                gradient.addColorStop(1, `hsla(${p.hue}, 100%, 50%, 0)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x, p.y, size * 2.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // ç»˜åˆ¶çˆ±å¿ƒå…‰æ™•
    function drawHeartGlow(ctx, canvas) {
        if (!heartCenterX || !heartTopY) return;

        const centerY = (heartTopY + heartBottomY) / 2;
        const glowSize = 200 + 50 * Math.sin(heartGlowPhase);

        // å¤–å±‚å…‰æ™•
        const gradient = ctx.createRadialGradient(
            heartCenterX, centerY, 0,
            heartCenterX, centerY, glowSize
        );
        gradient.addColorStop(0, 'rgba(255, 100, 150, 0.15)');
        gradient.addColorStop(0.5, 'rgba(200, 100, 200, 0.08)');
        gradient.addColorStop(1, 'rgba(150, 100, 250, 0)');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(heartCenterX, centerY, glowSize, 0, Math.PI * 2);
        ctx.fill();
    }

    function onload() {
        const canvas = document.getElementById('heart');
        const ctx = canvas.getContext('2d');

        points = JSON.parse(points)

        // è®¡ç®—æ‰€æœ‰å¸§ä¸­çˆ±å¿ƒçš„åæ ‡è¾¹ç•Œ
        minX = Infinity; maxX = -Infinity;
        minY = Infinity; maxY = -Infinity;

        for (let j = 0; j < points.length; j++) {
            const frame_points = points[j];
            for (let i = 0; i < frame_points["x"].length; i++) {
                let y = frame_points["x"][i]
                let x = frame_points["y"][i]
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
        }

        // çˆ±å¿ƒåŸå§‹å°ºå¯¸ï¼ˆåŠ ä¸€ç‚¹è¾¹è·ï¼‰
        const heartWidth = maxX - minX + 1;
        const heartHeight = maxY - minY + 1;

        // åˆ›å»ºç¦»å± canvasï¼Œå°ºå¯¸ä¸ºçˆ±å¿ƒåŸå§‹å¤§å°
        offscreenCanvas = document.createElement('canvas');
        offscreenCanvas.width = heartWidth;
        offscreenCanvas.height = heartHeight;
        offscreenCtx = offscreenCanvas.getContext('2d');

        // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼Œä½¿çˆ±å¿ƒå ç”»å¸ƒçš„ 3/5
        const targetWidth = canvas.width * 0.6;
        const targetHeight = canvas.height * 0.6;
        scale = Math.min(targetWidth / heartWidth, targetHeight / heartHeight);

        // è®¡ç®—çˆ±å¿ƒä½ç½®ä¿¡æ¯ç”¨äºç²’å­ç³»ç»Ÿ
        const destWidth = offscreenCanvas.width * scale;
        const destHeight = offscreenCanvas.height * scale;
        heartCenterX = canvas.width / 2;
        heartTopY = (canvas.height - destHeight) / 2;
        // çˆ±å¿ƒåº•éƒ¨Yåæ ‡ï¼ˆå‘ä¸Šåç§»è®©ç²’å­èƒ½è¿æ¥åˆ°çˆ±å¿ƒå°–ç«¯ï¼‰
        heartBottomY = heartTopY + destHeight - 100;

        // å¯ç”¨å›¾åƒå¹³æ»‘
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // åˆå§‹åŒ–æ‰€æœ‰ç²’å­ç³»ç»Ÿ
        initStars(canvas);
        initFireflies(canvas);
        initTrayParticles(canvas);

        console.log('çˆ±å¿ƒåŸå§‹å°ºå¯¸:', { heartWidth, heartHeight });
        console.log('ç¼©æ”¾æ¯”ä¾‹:', scale);
        console.log('ç¼©æ”¾åå°ºå¯¸:', { width: heartWidth * scale, height: heartHeight * scale });

        let currentFrame = 0;

        // ä½¿ç”¨å•ä¸ªå®šæ—¶å™¨å¾ªç¯æ’­æ”¾æ‰€æœ‰å¸§
        setInterval(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height)

            // å¶å°”ç”Ÿæˆæµæ˜Ÿï¼ˆ10% æ¦‚ç‡ï¼‰
            if (Math.random() < 0.1) {
                spawnMeteor(canvas);
            }

            // å¶å°”ç”ŸæˆçƒŸèŠ±ï¼ˆ3% æ¦‚ç‡ï¼‰
            if (Math.random() < 0.03) {
                spawnFirework(canvas);
            }

            // ç”Ÿæˆæ–°çš„é¾™å·é£ç²’å­ï¼ˆå¢åŠ å¯†åº¦ï¼‰
            for (let i = 0; i < 3; i++) {
                spawnTornadoParticle(canvas);
            }

            // æ›´æ–°ç²’å­
            updateParticles(canvas);

            // ç»˜åˆ¶é¡ºåºï¼ˆä»åº•å±‚åˆ°é¡¶å±‚ï¼‰ï¼š
            // 1. æ˜Ÿç©ºèƒŒæ™¯
            drawStars(ctx);

            // 2. æµæ˜Ÿ
            drawMeteors(ctx);

            // 3. è¤ç«è™«å…‰ç‚¹
            // drawFireflies(ctx);

            // 4. çƒŸèŠ±
            drawFireworks(ctx);

            // 5. æ‰˜ç›˜ç²’å­
            drawTrayParticles(ctx, canvas);

            // 6. çˆ±å¿ƒ
            update(ctx, canvas, points[currentFrame])
            currentFrame = (currentFrame + 1) % points.length;

            // 7. çˆ±å¿ƒå…‰æ™•
            drawHeartGlow(ctx, canvas);

            // 8. é¾™å·é£ç²’å­ï¼ˆæœ€é¡¶å±‚ï¼Œè¿æ¥åˆ°çˆ±å¿ƒï¼‰
            drawTornadoParticles(ctx, canvas);
        }, 50);
    }

    function update(ctx, canvas, frame_points) {
        // æ¸…ç©ºç¦»å± canvas
        offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);

        // åœ¨ç¦»å± canvas ä¸Šä»¥åŸå§‹å°ºå¯¸ç»˜åˆ¶ï¼ˆæ¯ç‚¹1åƒç´ ï¼‰
        const imageData = offscreenCtx.createImageData(offscreenCanvas.width, offscreenCanvas.height);

        for (let i = 0; i < frame_points["x"].length; i++) {
            let origY = frame_points["x"][i]
            let origX = frame_points["y"][i]
            let data = frame_points["data"][i]

            // ç›¸å¯¹äºè¾¹ç•Œåç§»
            let x = origX - minX;
            let y = origY - minY;

            if (x >= 0 && x < offscreenCanvas.width && y >= 0 && y < offscreenCanvas.height) {
                let index = (x + y * offscreenCanvas.width) * 4;
                let r = Math.min(255, data[2] * 1.2);
                let g = data[1];
                let b = data[0];

                // è®¡ç®—äº®åº¦ï¼Œæš—è‰²ç²’å­è®¾ä¸ºé€æ˜
                let brightness = (r + g + b) / 3;
                let alpha = brightness < 10 ? 0 : 255;

                imageData.data[index + 0] = r;
                imageData.data[index + 1] = g;
                imageData.data[index + 2] = b;
                imageData.data[index + 3] = alpha;
            }
        }

        offscreenCtx.putImageData(imageData, 0, 0);

        // è®¡ç®—ç»˜åˆ¶ä½ç½®ï¼Œä½¿çˆ±å¿ƒå±…ä¸­
        const destWidth = offscreenCanvas.width * scale;
        const destHeight = offscreenCanvas.height * scale;
        const destX = (canvas.width - destWidth) / 2;
        const destY = (canvas.height - destHeight) / 2;

        // ç”¨ drawImage ç¼©æ”¾ç»˜åˆ¶åˆ°ä¸» canvasï¼ˆæµè§ˆå™¨è‡ªåŠ¨æ’å€¼ï¼‰
        ctx.drawImage(offscreenCanvas, destX, destY, destWidth, destHeight);
    }

    // ====== Gesture Detection & Memory Mode ======

    // UI elements
    const gesturePrompt = document.getElementById('gesturePrompt');
    const cameraContainer = document.getElementById('cameraContainer');
    const cameraVideo = document.getElementById('cameraVideo');
    const cameraCanvas = document.getElementById('cameraCanvas');
    const detectionStatus = document.getElementById('detectionStatus');
    const memoryMode = document.getElementById('memoryMode');
    const memoryImage = document.getElementById('memoryImage');
    const memoryText = document.getElementById('memoryText');

    // Detection state
    let hands;
    let heartDetectedFrames = 0;
    const requiredFrames = 20;
    let isMemoryMode = false;

    // Memory images and texts
    const memoryFiles = [
        'DSC00508.JPG', 'IMG_2922.JPG', 'IMG_2924.JPG', 'IMG_2925.JPG', 'IMG_2926.JPG',
        'IMG_2927.JPG', 'IMG_2928.JPG', 'IMG_2929.jpg', 'IMG_2930.PNG', 'IMG_2931.PNG',
        'IMG_2932.jpg', 'IMG_2933.jpg', 'IMG_2934.JPG', 'IMG_2935.JPG', 'IMG_2936.JPG',
        'IMG_2937.JPG', 'IMG_2938.JPG', 'IMG_2939.JPG', 'IMG_2941.jpg', 'IMG_2943.JPG',
        'IMG_2944.JPG', 'IMG_2945.JPG', 'IMG_2946.JPG', 'IMG_2947.JPG', 'IMG_2948.JPG',
        'IMG_2949.JPG', 'IMG_2950.JPG', 'IMG_2951.JPG', 'IMG_2952.JPG', 'IMG_2953.JPG',
        'IMG_2954.JPG', 'IMG_2955.JPG', 'IMG_2956.JPG', 'IMG_2957.JPG', 'IMG_2958.JPG',
        'IMG_2959.JPG', 'IMG_2960.JPG', 'IMG_2961.JPG', 'IMG_2962.JPG', 'IMG_2963.JPG',
        'IMG_2964.JPG', 'IMG_2965.JPG', 'IMG_2966.JPG', 'IMG_2967.JPG', 'IMG_2968.JPG',
        'IMG_2969.JPG', 'IMG_2970.JPG', 'IMG_2971.JPG', 'IMG_2972.JPG', 'IMG_2973.JPG',
        'IMG_2974.JPG', 'IMG_2975.JPG', 'IMG_2981.JPG', 'IMG_2982.JPG', 'IMG_2983.JPG',
        'IMG_2984.JPG', 'IMG_2985.JPG', 'IMG_2986.JPG', 'IMG_2987.JPG', 'IMG_2988.JPG',
        'IMG_2989.jpg', 'IMG_2990.JPG', 'IMG_2991.JPG', 'IMG_2993.JPG', 'IMG_2994.JPG',
        'IMG_2995.JPG', 'IMG_2996.JPG', 'IMG_2997.JPG', 'IMG_2998.JPG', 'IMG_2999.JPG',
        'IMG_3001.JPG', 'IMG_3002.JPG', 'IMG_3003.JPG', 'IMG_3004.JPG', 'IMG_3005.JPG',
        'IMG_3006.JPG', 'IMG_3007.JPG', 'IMG_3008.JPG', 'IMG_3009.JPG', 'IMG_3010.JPG',
        'IMG_3011.JPG', 'IMG_3012.JPG', 'IMG_3013.JPG', 'IMG_3014.JPG', 'IMG_3015.JPG',
        'IMG_3016.JPG', 'IMG_3025.JPG', 'IMG_3026.JPG', 'IMG_3027.JPG', 'IMG_3028.JPG'
    ];

    const memoryTexts = [
        'é‚£æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€æ¬¡ç›¸é‡',
        'ä½ çš„ç¬‘å®¹ï¼Œå¦‚é˜³å…‰èˆ¬æ¸©æš–',
        'é‚£äº›ç¾å¥½çš„ç¬é—´',
        'æˆ‘ä»¬ä¸€èµ·èµ°è¿‡çš„æ¯ä¸€æ­¥',
        'ä½ è¯´çš„æ¯ä¸€å¥è¯ï¼Œæˆ‘éƒ½è®°å¾—',
        'é‚£å¤©çš„å¤©æ°”å¾ˆå¥½ï¼Œä½ æ›´å¥½',
        'å’Œä½ åœ¨ä¸€èµ·çš„æ¯ä¸€åˆ»',
        'éƒ½æ˜¯æˆ‘æœ€çè´µçš„å›å¿†',
        'ä½ è®©æˆ‘ç›¸ä¿¡',
        'è¿™ä¸–ç•Œä¸ŠçœŸçš„æœ‰ç«¥è¯',
        'æˆ‘æƒ³ç‰µç€ä½ çš„æ‰‹',
        'ä¸€ç›´èµ°åˆ°ä¸–ç•Œçš„å°½å¤´',
        'ä½ çŸ¥é“å—',
        'é‡è§ä½ æ˜¯æˆ‘æœ€å¤§çš„å¹¸è¿',
        'ä»é‚£å¤©èµ·',
        'æˆ‘çš„ä¸–ç•Œå¼€å§‹æœ‰äº†é¢œè‰²',
        'æ¯ä¸€æ¬¡çœ‹åˆ°ä½ ',
        'æˆ‘çš„å¿ƒéƒ½ä¼šè·³å¾—å¾ˆå¿«',
        'æˆ‘æƒ³æŠŠæ‰€æœ‰çš„æ¸©æŸ”',
        'éƒ½ç»™ä½ ä¸€ä¸ªäºº',
        'å’Œä½ ä¸€èµ·çš„æ—¶å…‰',
        'æ˜¯æˆ‘æœ€å¿«ä¹çš„æ—¶å…‰',
        'ä½ çš„æ¯ä¸€ä¸ªè¡¨æƒ…',
        'æˆ‘éƒ½æƒ³æ°¸è¿œè®°ä½',
        'é‚£äº›ä¸€èµ·çš„æ—¥å­',
        'æ˜¯æˆ‘ç”Ÿå‘½ä¸­æœ€ç¾çš„é£æ™¯',
        'æˆ‘æƒ³å’Œä½ ä¸€èµ·',
        'çœ‹éä¸–é—´æ‰€æœ‰çš„ç¾å¥½',
        'ä½ å°±æ˜¯æˆ‘çš„æ˜Ÿè¾°å¤§æµ·',
        'æ˜¯æˆ‘æ‰€æœ‰çš„æ¢¦æƒ³',
        'å’Œä½ åœ¨ä¸€èµ·',
        'æ¯ä¸€å¤©éƒ½æ˜¯æ–°çš„å¼€å§‹',
        'æˆ‘æƒ³é™ªä½ çœ‹æ—¥å‡ºæ—¥è½',
        'é™ªä½ åº¦è¿‡æ¯ä¸€ä¸ªæ˜¥å¤ç§‹å†¬',
        'ä½ æ˜¯æˆ‘çš„å”¯ä¸€',
        'æ˜¯æˆ‘æ­¤ç”Ÿæœ€ç¾çš„é‡è§',
        'é‚£äº›æ¸©æš–çš„ç¬é—´',
        'æˆ‘ä¼šæ°¸è¿œçè—',
        'ä½ è®©æˆ‘æ˜ç™½',
        'ä»€ä¹ˆæ˜¯çœŸæ­£çš„å¹¸ç¦',
        'æˆ‘æƒ³ç»™ä½ æœ€å¥½çš„ä¸€åˆ‡',
        'ç”¨æˆ‘å…¨éƒ¨çš„çˆ±',
        'æ¯ä¸€æ¬¡ç›¸é‡',
        'éƒ½æ˜¯ä¹…åˆ«é‡é€¢',
        'ä½ åœ¨çš„åœ°æ–¹',
        'å°±æ˜¯æˆ‘çš„å®¶',
        'æˆ‘æƒ³å’Œä½ ä¸€èµ·',
        'åˆ›é€ æ›´å¤šç¾å¥½çš„å›å¿†',
        'ä½ æ˜¯æˆ‘å¿ƒä¸­',
        'æœ€æŸ”è½¯çš„é‚£ä¸€éƒ¨åˆ†',
        'å’Œä½ çš„æ¯ä¸€å¼ ç…§ç‰‡',
        'éƒ½æ˜¯æˆ‘æœ€çè´µçš„å®è—',
        'æˆ‘æƒ³æŠŠè¿™äº›ç¾å¥½',
        'éƒ½ç•™åœ¨æ—¶å…‰é‡Œ',
        'ä½ çŸ¥é“å—',
        'ä½ å°±æ˜¯æˆ‘çš„å…¨ä¸–ç•Œ',
        'é‚£äº›ç¬‘å®¹å’Œæ³ªæ°´',
        'éƒ½æ˜¯æˆ‘ä»¬çˆ±çš„è¯æ˜',
        'æˆ‘æƒ³å¯¹ä½ è¯´',
        'è°¢è°¢ä½ å‡ºç°åœ¨æˆ‘çš„ç”Ÿå‘½é‡Œ',
        'æœªæ¥çš„æ¯ä¸€å¤©',
        'æˆ‘éƒ½æƒ³å’Œä½ ä¸€èµ·åº¦è¿‡',
        'ä½ æ˜¯æˆ‘çš„é˜³å…‰',
        'ç…§äº®äº†æˆ‘çš„æ•´ä¸ªä¸–ç•Œ',
        'è¿™äº›å›å¿†',
        'æ˜¯æˆ‘ä»¬çˆ±æƒ…æœ€ç¾çš„è§è¯',
        'æˆ‘çˆ±ä½ ',
        'ä»è¿‡å»åˆ°ç°åœ¨ï¼Œåˆ°æ°¸è¿œ',
        'æ„¿æˆ‘ä»¬çš„æ•…äº‹',
        'æ°¸è¿œæ²¡æœ‰ç»“å±€',
        'åªæœ‰ä¸€ä¸ªåˆä¸€ä¸ª',
        'ç¾å¥½çš„å¼€å§‹',
        'ä½ ï¼Œå°±æ˜¯æˆ‘çš„',
        'happily ever after',
        'æˆ‘æƒ³å’Œä½ ',
        'ä¸€ç›´è¿™æ ·å¹¸ç¦ä¸‹å»',
        'ç›´åˆ°æ°¸è¿œ',
        'æˆ‘çˆ±ä½  ğŸ’—'
    ];

    // Show prompt after 2 seconds
    setTimeout(() => {
        if (!isMemoryMode) {
            gesturePrompt.style.display = 'block';
            initGestureDetection();
        }
    }, 2000);

    // Initialize gesture detection
    async function initGestureDetection() {
        hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: 640,
                    height: 480,
                    facingMode: 'user'
                }
            });

            cameraVideo.srcObject = stream;
            await cameraVideo.play();

            cameraCanvas.width = 640;
            cameraCanvas.height = 480;
            cameraContainer.style.display = 'block';
            detectionStatus.style.display = 'block';

            // Send video frames to hands detection
            async function detectFrame() {
                if (!isMemoryMode && cameraVideo.readyState === cameraVideo.HAVE_ENOUGH_DATA) {
                    await hands.send({ image: cameraVideo });
                }
                if (!isMemoryMode) {
                    requestAnimationFrame(detectFrame);
                }
            }
            detectFrame();
        } catch (error) {
            detectionStatus.textContent = 'æ— æ³•è®¿é—®æ‘„åƒå¤´: ' + error.message;
            console.error('Camera error:', error);
        }
    }

    // Detect overhead heart gesture
    function detectOverheadHeartGesture(landmarks) {
        if (landmarks.length !== 2) return { isHeart: false, debug: 'éœ€è¦åŒæ‰‹' };

        const hand1 = landmarks[0];
        const hand2 = landmarks[1];

        // Get key points
        const thumb1Tip = hand1[4];
        const index1Tip = hand1[8];
        const thumb2Tip = hand2[4];
        const index2Tip = hand2[8];
        const wrist1 = hand1[0];
        const wrist2 = hand2[0];

        const distance = (p1, p2) => {
            return Math.sqrt(
                Math.pow(p1.x - p2.x, 2) +
                Math.pow(p1.y - p2.y, 2) +
                Math.pow(p1.z - p2.z, 2)
            );
        };

        const thumbDistance = distance(thumb1Tip, thumb2Tip);
        const indexDistance = distance(index1Tip, index2Tip);

        // Check if hands are above head (lower y value = higher position)
        const avgWristY = (wrist1.y + wrist2.y) / 2;
        const avgFingerY = (thumb1Tip.y + thumb2Tip.y + index1Tip.y + index2Tip.y) / 4;

        const isOverhead = avgWristY < 0.4; // Hands should be in upper part of frame
        const isHeartShape = thumbDistance < 0.15 && indexDistance < 0.15;

        return {
            isHeart: isOverhead && isHeartShape,
            debug: `è¶Šè¿‡å¤´é¡¶: ${isOverhead}, çˆ±å¿ƒå½¢çŠ¶: ${isHeartShape}`
        };
    }

    // Draw hand landmarks
    function drawLandmarks(landmarks) {
        const ctx = cameraCanvas.getContext('2d');
        ctx.clearRect(0, 0, cameraCanvas.width, cameraCanvas.height);

        for (let hand of landmarks) {
            // Draw points
            for (let i = 0; i < hand.length; i++) {
                const point = hand[i];
                const x = point.x * cameraCanvas.width;
                const y = point.y * cameraCanvas.height;

                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = (i === 4 || i === 8) ? '#ff0000' : '#00ff00';
                ctx.fill();
            }

            // Draw connections
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],
                [0, 5], [5, 6], [6, 7], [7, 8],
                [0, 9], [9, 10], [10, 11], [11, 12],
                [0, 13], [13, 14], [14, 15], [15, 16],
                [0, 17], [17, 18], [18, 19], [19, 20]
            ];

            ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            for (let [start, end] of connections) {
                const p1 = hand[start];
                const p2 = hand[end];
                ctx.beginPath();
                ctx.moveTo(p1.x * cameraCanvas.width, p1.y * cameraCanvas.height);
                ctx.lineTo(p2.x * cameraCanvas.width, p2.y * cameraCanvas.height);
                ctx.stroke();
            }
        }
    }

    // Handle hands detection results
    function onHandsResults(results) {
        if (isMemoryMode) return; // Don't process if already in memory mode

        if (results.multiHandLandmarks) {
            drawLandmarks(results.multiHandLandmarks);
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
            const result = detectOverheadHeartGesture(results.multiHandLandmarks);

            if (result.isHeart) {
                heartDetectedFrames++;
                const progress = Math.floor((heartDetectedFrames / requiredFrames) * 100);
                detectionStatus.textContent = `æ£€æµ‹åˆ°çˆ±å¿ƒæ‰‹åŠ¿ï¼${progress}%`;
                detectionStatus.style.color = '#ff69b4';

                if (heartDetectedFrames >= requiredFrames) {
                    detectionStatus.textContent = 'æˆåŠŸï¼è¿›å…¥å›å¿†æ¨¡å¼...';
                    setTimeout(() => {
                        startMemoryMode();
                    }, 500);
                }
            } else {
                heartDetectedFrames = Math.max(0, heartDetectedFrames - 1);
                detectionStatus.textContent = result.debug;
                detectionStatus.style.color = '#ffeb3b';
            }
        } else {
            heartDetectedFrames = Math.max(0, heartDetectedFrames - 2);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 1) {
                detectionStatus.textContent = 'è¯·ä½¿ç”¨åŒæ‰‹';
            } else {
                detectionStatus.textContent = 'è¯·å°†åŒæ‰‹æ”¾åœ¨é•œå¤´å‰';
            }
            detectionStatus.style.color = '#ffffff';
        }
    }

    // Start memory slideshow
    function startMemoryMode() {
        isMemoryMode = true;

        // Hide detection UI
        gesturePrompt.style.display = 'none';
        cameraContainer.style.display = 'none';
        detectionStatus.style.display = 'none';

        // Stop camera stream
        if (cameraVideo.srcObject) {
            const tracks = cameraVideo.srcObject.getTracks();
            tracks.forEach(track => track.stop());
            cameraVideo.srcObject = null;
        }

        // Show memory mode
        memoryMode.style.display = 'block';
        setTimeout(() => {
            memoryMode.classList.add('show');
        }, 50);

        // Start slideshow
        let currentIndex = 0;
        showMemory(currentIndex);

        function showMemory(index) {
            if (index >= memoryFiles.length) {
                // End of slideshow
                setTimeout(() => {
                    memoryText.textContent = 'è¿™å°±æ˜¯æˆ‘ä»¬çš„æ•…äº‹ ğŸ’—';
                    memoryText.classList.add('show');
                }, 2000);
                return;
            }

            // Hide current
            memoryImage.classList.remove('show');
            memoryText.classList.remove('show');

            setTimeout(() => {
                // Load new image
                memoryImage.src = 'memorys/' + memoryFiles[index];
                memoryText.textContent = memoryTexts[index % memoryTexts.length];

                // Show new
                setTimeout(() => {
                    memoryImage.classList.add('show');
                    memoryText.classList.add('show');
                }, 100);

                // Next image after 4 seconds
                setTimeout(() => {
                    showMemory(index + 1);
                }, 4000);
            }, 1500); // Wait for fade out
        }
    }
</script>

</html>